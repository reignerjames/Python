student_number = 0
student_name = "Reigner Casangcapan"

from turtle import *
from math import *
from random import randint, choice, seed
from sys import exit as abort

if not isinstance(student_number, int):
    print('\nUnable to run: No student number supplied',
          '(must be an integer), aborting!\n')
    abort()
if not isinstance(student_name, str):
    print('\nUnable to run: No student name supplied',
          '(must be a character string), aborting!\n')
    abort()

# When the tracer is True, ensure rendering of drawing is at its fastest
speed("fastest")


cell_side = 60  # pixels

# Define the overall size of our "flat top" hexagonal grid
grid_width = 9   # hexagonal cells
grid_height = 9  # hexagonal cells

# To ensure that the grid has a cell at the centre, the arithmetic
# below supports only certain grid sizes
assert [grid_width, grid_height] in \
       [[5, 5],  [9, 5],   [13, 5],
        [7, 7],  [11, 7],  [15, 7],
        [5, 9],  [9, 9],   [13, 9],
        [7, 11], [11, 11], [15, 11],
        [5, 13], [9, 13],  [13, 13]], 'Invalid grid dimensions'

# cell width for a grid with "flat top" orientation
cell_width = cell_side * 2

# cell height and distance from neighbours
cell_height = round(2 * (cell_side * sin(radians(60))))

# distance between grid cells horizontally
horiz_spacing = round(3 / 4 * cell_width)

# distance between grid cells vertically
vert_spacing = cell_height / 2

# the total size of the margins left and right of the grid
x_margins = horiz_spacing * 5.5

# the total size of the margins below and above the grid
y_margins = vert_spacing * 4

# the drawing canvas' height
window_height = int(((grid_height + 1) * vert_spacing) + y_margins)

# the drawing canvas' width
window_width = int((grid_width * horiz_spacing) + x_margins)

# text font for labels on grid axes
coord_font = ('Arial', cell_side // 3, 'normal')

# text font for instructions
label_font = ('Arial', cell_side // 2, 'normal')


# Set up the canvas and draw the background for the overall image
def create_drawing_canvas(canvas_title="Put your solution's title here",
                          bg_colour='darkseagreen',
                          line_colour='slate grey',
                          draw_grid=True,
                          write_instructions=True):

    # Set up the drawing canvas with enough space for the grid and margins
    setup(window_width, window_height)
    bgcolor(bg_colour)
    title(canvas_title)

    # Draw the canvas as quickly as possible
    tracer(False)

    # Get ready to draw the grid
    penup()
    color(line_colour)
    width(2)

    # Determine the left-bottom coords of the grid (defined
    # as the left-most point of the bottom-left cell)
    left_edge = -(((grid_width // 2) * horiz_spacing) + (0.5 * cell_width))
    bottom_edge = -((grid_height - 1) // 2) * vert_spacing
    goto(left_edge, bottom_edge)

    # Optionally draw the grid
    if draw_grid:
        # Draw the cells row by row
        for rows in range(ceil(grid_height / 2)):
            # Draw upper half of row
            goto(left_edge, bottom_edge + (rows * cell_height))
            pendown()
            # face east
            setheading(0)
            for angle in ([60, -60, -60, 60] * ceil(grid_width / 2))[:-1]:
                left(angle)
                forward(cell_side)
            penup()
            # Draw lower half of row
            goto(left_edge, bottom_edge + (rows * cell_height))
            pendown()
            # face east
            setheading(0)
            for angle in ([-60, 60, 60, -60] * ceil(grid_width / 2))[:-1]:
                left(angle)
                forward(cell_side)
            penup()

        # Label the x axis
        penup()
        y_offset = cell_height // 1.2  # pixels
        for x_label in range(grid_width):
            goto(left_edge - (cell_width // 4) + ((x_label + 1) * (cell_width // 1.32)),
                 bottom_edge - y_offset)
            write(chr(x_label + ord('A')), align='left', font=coord_font)

        # Label the y axis
        penup()
        x_offset, y_offset = cell_side * 0.7, cell_height // 10  # pixels
        for y_label in range(grid_height):
            goto(left_edge + (horiz_spacing * grid_width) + x_offset,
                 bottom_edge + (y_label * (cell_height // 2)) - y_offset)
            write(str(y_label + 1), align='center', font=coord_font)

        # Mark the home cell (assuming a grid of size at least 9 x 9)
        home()
        dot(cell_side // 4)

    # Optionally write instructions for the programmer
    if write_instructions:
        # Write to the left of the grid
        goto(-((grid_width / 1.8) * horiz_spacing), -(vert_spacing // 0.7))
        write('Replace\nthis with\nyour\nsymbol',
              align='right', font=label_font)
        # Write to the right of the grid
        goto((grid_width / 1.7) * horiz_spacing, -(vert_spacing // 0.7))
        write('Replace\nthis \nwith the\ncurrent\ndirection',
              align='left', font=label_font)
        # Write above the grid
        goto(0, 2 * vert_spacing * (grid_height / 3.2))
        write('Replace this with your final message',
              align='center', font=label_font)

    pencolor('black')
    width(1)
    penup()
    home()
    tracer(True)

def release_drawing_canvas(signature, text_colour='slate grey'):
    tracer(True)
    color(text_colour)
    penup()
    goto(-(horiz_spacing * grid_width) / 2,
         -(((grid_height - 1) // 2) + 2.8) * vert_spacing)
    write('Visualisation by ' + signature,
          align='left', font=label_font)
    # Hide the cursor and release the window
    hideturtle()
    done()

def raw_data():
    # Define the possible ways the object can move and turn
    moves = ['Forward', 'Forward and turn left', 'Forward and turn right']
    # Define the possible initial orientations
    directions = ['North', 'North east', 'South east',
                  'South', 'South west', 'North west']

    # Choose the number of moves
    num_moves = randint(1, 10)
    # Choose the object's initial energy level
    # (which mustn't exceed the number of moves)
    energy = randint(1, num_moves)
    # Choose the object's initial orientation
    direction = choice(directions)

    # Keep track of how many moves have been created in total
    move_no = 0

    # Initialise the dataset with the special first move
    random_moves = [[move_no, energy, direction]]

    # Create the remaining moves
    while move_no < num_moves:
        # Increment move number
        move_no = move_no + 1
        # Choose which way the object moves and turns
        move = choice(moves)
        # Add the new move to the dataset
        random_moves.append([move_no, move])

    # Print the whole dataset to the shell window, laid out
    # nicely, one move per line
    print("The moves to visualise are:\n")
    print(str(random_moves).replace('],', '],\n'))

    # Return the dataset to the caller
    return random_moves

def data_set(new_seed=randint(0, 99999)):
    print('Using random number seed', new_seed, '...\n')
    # set the seed
    seed(new_seed)
    # return the random data set
    return raw_data()

def visualise_data(data):
    # Set Title and speed of turtle
    title("Snoopy's Playground Run! (Snoopy by Reigner Casangcapan)")
    speed('fastest')
    # Set the position of the heading
    heading_postion = (0, 300)
    # Indicates whether Snoopy has completed a successful run
    succesful_completion = True

    # Draw character (Snoopy)
    def draw_snoopy():
        scale = 0.2  # Determines size of Snoopy
        pensize('1')
        setheading(0)  # Set initial heading

        # Draws Snoopy's nose
        def nose():
            fillcolor('black')
            begin_fill()
            right(90)
            circle(20 * scale, 190)
            left(90)
            end_fill()
            forward(10 * scale)
            left(40)
            forward(9 * scale)
            pencolor('white')
            dot(9 * scale)
            pencolor('black')
            penup()
            left(165)
            forward(11 * scale)
            right(20)
            pendown()

        # Draws Snoopy's eye
        def eye():
            penup()
            left(120)
            forward(70 * scale)
            pendown()
            fillcolor('black')
            begin_fill()
            circle(4 * scale, 180)
            forward(5 * scale)
            circle(4 * scale, 180)
            forward(5 * scale)
            end_fill()
            penup()
            right(180)
            forward(70 * scale)
            left(60)
            pendown()

        # Draws Snoopy's ear
        def ear():
            right(215)
            forward(12 * scale)
            right(180)
            circle(70 * scale, 40)
            forward(10 * scale)
            circle(70 * scale, 20)
            forward(10 * scale)
            circle(70 * scale, 50)
            forward(5 * scale)
            circle(40 * scale, 160)
            forward(15 * scale)
            circle(55 * scale, 50)

        # Draws spot on Snoopy's ear
        def ear_spot():
            penup()
            forward(15 * scale)
            right(90)
            pendown()
            begin_fill()
            circle(26 * scale, 145)
            forward(15 * scale)
            circle(45 * scale, 30)
            circle(26 * scale, 145)
            forward(20 * scale)
            circle(24 * scale, 33)
            forward(8 * scale)
            end_fill()
            penup()
            left(140)
            forward(80 * scale)
            left(45)
            pendown()

        # Draws Snoopy's Collar
        def collar():
            fillcolor('red')
            begin_fill()
            left(68)
            backward(5 * scale)
            forward(40 * scale)
            right(90)
            forward(10 * scale)
            right(90)
            forward(40 * scale)
            right(90)
            forward(10 * scale)
            end_fill()
            penup()
            backward(10 * scale)
            right(180)
            pendown()

        # Draws Snoopy's tail
        def tail():
            right(90)
            circle(-50 * scale, 65)
            right(150)
            circle(50 * scale, 55)

        # Draws Snoopy's toelines for left foot
        def footline():
            left(90)
            forward(5 * scale)
            circle(20 * scale, 45)
            penup()
            circle(20 * scale, 315)
            backward(5 * scale)
            right(90)
            pendown()

        # Draws Snoopy's toelines for right foot
        def reverse_footline():
            right(135)
            forward(5 * scale)
            circle(20 * scale, 45)
            penup()
            circle(20 * scale, 315)
            backward(5 * scale)
            left(90)
            pendown()

        # Draws lines on Snoopy's paw
        def paw_line():
            right(90)
            circle(10 * scale, 30)
            penup()
            circle(10 * scale, 330)
            left(90)
            pendown()

        # Draws Snoopy's arm
        def arm():
            circle(-80 * scale, 10)
            forward(40 * scale)
            circle(-15 * scale, 90)
            paw_line()
            circle(-15 * scale, 60)
            paw_line()
            circle(-15 * scale, 30)
            for i in range(3):
                forward(10 * scale)
                right(5)

        # Draws spot on Snoopy's back
        def backspot():
            left(90)
            penup()
            forward(29 * scale)
            left(140)
            fillcolor('black')
            begin_fill()
            circle(-20 * scale, 110)
            end_fill()

        # Draws Snoopy and calls all defined functions
        pendown()
        left(45)
        forward(10 * scale)
        right(5)
        forward(10 * scale)
        right(10)
        forward(20 * scale)
        right(15)
        forward(30 * scale)
        right(5)
        forward(15 * scale)
        circle(50 * scale, 85)
        forward(5 * scale)
        nose()
        circle(70 * scale, 70)
        forward(35 * scale)
        right(45)
        circle(50 * scale, 35)
        eye()
        forward(20 * scale)
        circle(70 * scale, 70)
        ear()
        left(90)
        ear_spot()
        circle(-35 * scale, 50)
        forward(12 * scale)
        collar()
        circle(-45 * scale, 50)
        circle(70 * scale, 70)
        forward(15 * scale)
        tail()
        right(120)
        circle(70 * scale, 20)
        right(30)
        forward(30 * scale)
        circle(-40 * scale, 40)
        circle(40 * scale, 40)
        left(45)
        circle(40 * scale, 40)
        forward(30 * scale)
        footline()
        circle(40 * scale, 25)
        right(20)
        footline()
        for i in range(8):
            left(20)
            forward(5 * scale)
            circle(50 * scale, 20)
            forward(5 * scale)
            right(90)
            forward(20 * scale)
            circle(-50 * scale, 10)
            right(75)
            circle(-50 * scale, 10)
            circle(50 * scale, 10)
            right(90)
            circle(-50 * scale, 20)
            left(100)
            forward(10 * scale)
            circle(-50 * scale, 50)
        for i in range(2):
            right(20)
            forward(5 * scale)
            right(25)
            forward(5 * scale)
            circle(-25 * scale, 10)
        reverse_footline()
        forward(5 * scale)
        right(20)
        forward(20 * scale)
        penup()
        forward(10 * scale)
        right(65)
        forward(50 * scale)
        right(110)
        pendown()
        circle(55 * scale, 90)
        for i in range(5):
            forward(5 * scale)
            left(5)
        forward(50 * scale)
        left(15)
        forward(40 * scale)
        left(10)
        forward(10 * scale)
        left(15)
        forward(3 * scale)
        penup()
        left(90)
        forward(40 * scale)
        left(55)
        pendown()
        arm()
        backspot()

    # Creates a white cell (Hexagon)
    def draw_hexagon():
        setheading(0)
        color('white')
        penup()
        begin_fill()
        forward(60)
        right(120)
        pendown()
        pencolor('black')
        pensize('2')
        for i in range(6):
            forward(60)
            right(60)
        end_fill()
        penup()
        setheading(0)
        backward(60)
        pendown()

    # Combines hexagon and snoopy drawing to minimise code
    def combined_symbol():
        tracer(True)
        draw_hexagon()
        tracer(False)
        draw_snoopy()

    # Draws the legend on left side of screen
    def draw_legend():
        goto(-550, 0)
        combined_symbol()
        goto(-550, -75)
        write('SNOOPY!',
              align='center',
              font=('Arial', 15))

    # Calls functions to draw the legend, and first (centre) Snoopy
    draw_legend()
    home()
    combined_symbol()

    # Returns compass direction based on the turtle's current heading
    def get_heading_direction():
        angle = heading()
        if angle == 0:
            return "East"
        elif angle == 90:
            return "North"
        elif angle == 30:
            return "North east"
        elif angle == 330:
            return "South east"
        elif angle == 270:
            return "South"
        elif angle == 210:
            return "South west"
        elif angle == 150:
            return "North west"
        else:
            # If compass breaks, or contains incorrect value: write unknown
            return "Unknown"

    # Updates current direction to match turtle's heading
    current_direction = get_heading_direction()

    # Allocates directions to angles
    def angle_n_direction(new_direction):
        angle_of_turtle = {
            'North': 90,
            'North east': 30,
            'South east': 330,
            'South': 270,
            'South west': 210,
            'North west': 150
        }
        # Check if direction is valid
        if new_direction in angle_of_turtle:
            setheading(angle_of_turtle[new_direction])  # Set turtle's heading
            compass(new_direction)
        else:
            print(f"Invalid direction: {new_direction}")

    # Updates compass separately to avoid interfering with main drawing
    compass_turtle = Turtle()
    compass_turtle.hideturtle()
    compass_turtle.penup()
    compass_turtle.speed('fastest')

    # Compass to indicate the current heading that Snoopy is facing
    def compass(current_direction):
        compass_turtle.clear()  # Clear previous direction
        save_pos = pos()  # Save current coordinates
        save_heading = heading()  # Save current heading
        compass_turtle.goto(583, 20)
        compass_turtle.write(f'Current Direction:\n {current_direction}',
                             align='right', font=('Arial', 15))
        # Return to the original position and heading
        goto(save_pos)  # Return to saved position
        setheading(save_heading)  # Return to saved heading

    compass(current_direction)  # Updates compass to show current turtle heading

    # Draws a red prohibited over Snoopy if out of bounds
    def draw_mark():
        rad = 30
        pencolor('red')
        pensize(5)
        penup()
        setheading(0)
        forward(rad)
        pendown()
        setheading(270)
        circle(-rad, 585)
        right(90)
        forward(rad * 2)
        penup()
        color('black')

    # Set variables for each variable in data set by indexing the list
    energy = data[0][1]
    initial_direction = data[0][2]
    num_steps = data[0][0]

    home()
    angle_n_direction(initial_direction)  # Sets turtle's initial heading

    # Loops through each move in the dataset after the initial step
    for move in data[1:]:
        xy_position = (xcor(), ycor())  # Save current coordinates
        saved_heading = heading()  # Save current heading
        num_steps, step_instruction = move  # Extracts step number & instruction

        # Abort if energy falls below zero
        if energy <= 0:
            goto(heading_postion)
            write("Snoopy is out of energy", align='center', font=('Arial', 16,
                                                                   'bold'))
            succesful_completion = False  # Set completion to false to abort
            break

        forward(104)  # Moves turtle to next cell after every move

        # Abort if turtle is outside border
        if abs(xcor()) > 365 or abs(ycor()) > 215:
            succesful_completion = False
            goto(xy_position)
            draw_mark()
            goto(heading_postion)
            write("Snoopy moved out of the grid", align='center', font=('Arial',
                                                                        16, 'bold'))
            break

        xy_position = (xcor(), ycor())  # Saves current coordinates of turtle
        saved_heading = heading()  # Saves current heading turtle

        # Writes the step number into the cell
        pendown()
        combined_symbol()
        penup()
        goto(xy_position)
        setheading(350)
        forward(45)
        write(str(num_steps), align='center', font=('Arial', 14, 'normal'))
        backward(45)
        setheading(saved_heading)

        # Determines turn direction, then turns left or right by 60 degrees
        if step_instruction == 'Forward and turn left':
            left(60)
            compass(get_heading_direction())  # Update compass after turn
        elif step_instruction == 'Forward and turn right':
            right(60)
            compass(get_heading_direction())
        energy -= 1  # Increment energy

    # Indicate and write when a successful run has been completed by Snoopy
    if succesful_completion:
        goto(heading_postion)
        write("Snoopy has completed the run!", align='center', font=('Arial', 16,
                                                                     'bold'))

create_drawing_canvas(write_instructions=False)
tracer(True)

visualise_data(data_set()) 

release_drawing_canvas(student_name)

